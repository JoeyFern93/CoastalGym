<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>Instant Replay (Web) ‚Äî Camera with Adjustable Delay</title>
  <style>
    :root {
      --bg: #0b0f14; --card: #121821; --muted: #97a0ad; --text: #e8eef6; --accent: #4cc9f0; --accent2:#90ee90;
    }
    html, body { height: 100%; }
    body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial; background: var(--bg); color: var(--text); }
    header { padding: 14px 18px; border-bottom: 1px solid #1e2633; display: flex; align-items: center; gap: 12px; flex-wrap: wrap; }
    header h1 { font-size: 18px; margin: 0; letter-spacing: 0.2px; }
    .pill { background: #182232; border:1px solid #243149; padding:6px 10px; border-radius: 999px; font-size: 12px; color: var(--muted); }

    .wrap { max-width: 1200px; margin: 0 auto; padding: 16px; display: grid; grid-template-columns: 330px 1fr; gap: 16px; }
    @media (max-width: 980px) { .wrap { grid-template-columns: 1fr; } }

    .panel { background: var(--card); border:1px solid #1e2633; border-radius: 14px; padding: 14px; }
    .panel h2 { font-size: 14px; font-weight: 600; margin: 0 0 10px; color: var(--muted); letter-spacing:.2px; }

    .controls { display: grid; gap: 12px; }
    label { display: grid; gap: 6px; font-size: 12px; color: var(--muted); }
    select, input[type="number"], input[type="range"] { -webkit-appearance:none; appearance:none; width: 100%; background:#0e1520; color: var(--text); padding:10px 12px; border-radius: 10px; border:1px solid #243149; outline:none; font-size: 14px; }
    input[type="range"] { height: 36px; padding: 0 2px; }
    .row { display:flex; gap:10px; }
    .row > * { flex:1; }

    .btn { display:inline-flex; align-items:center; justify-content:center; gap:8px; background: linear-gradient(180deg, #1c2535, #131b29); color: #eaf4ff; border:1px solid #22314a; padding:10px 12px; border-radius:12px; cursor:pointer; font-weight:600; user-select:none; }
    .btn.primary { background: linear-gradient(180deg, #2986ff, #0f66d6); border-color:#0f66d6; }
    .btn.success { background: linear-gradient(180deg, #22c55e, #16a34a); border-color:#15803d; }
    .btn[disabled] { opacity:.6; cursor:not-allowed; }

    .video-grid { display:grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    @media (max-width: 980px) { .video-grid { grid-template-columns: 1fr; } }

    .video-card { position: relative; background:#000; border-radius:14px; overflow:hidden; border:1px solid #1e2633; }
    .video-card header { position:absolute; inset:auto 0 0 0; background:linear-gradient(180deg, transparent, rgba(0,0,0,.5)); display:flex; justify-content:space-between; align-items:center; padding:8px 10px; gap:8px; border:none; }
    .video-card header .tag { font-size:12px; color:#d2dbe7; background: rgba(0,0,0,.35); border:1px solid rgba(255,255,255,.12); padding:4px 8px; border-radius:999px; }
    .mirrored { transform: scaleX(-1); }

    video, canvas { width: 100%; height: auto; display:block; background:#000; }
    .statline { margin-top:8px; font-size:12px; color: var(--muted); display:flex; gap: 12px; flex-wrap:wrap; }

    .note { font-size: 12px; color: var(--muted); line-height: 1.5; }
    .warn { color:#ffd166; }
    footer { max-width: 1200px; margin: 8px auto 24px; padding: 0 16px; }
  </style>
</head>
<body>
  <header>
    <h1>Instant Replay (Gym)</h1>
    <span class="pill">Works on Safari, Chrome, Edge (HTTPS required)</span>
    <button id="popOutBtn" class="btn" style="margin-left:auto">‚Üó Open Standalone</button>
  </header>

  <div class="wrap">
    <aside class="panel">
      <h2>Controls</h2>
      <div class="controls">
        <label>
          Camera
          <select id="cameraSelect"></select>
        </label>
        <div class="row">
          <label>
            Resolution
            <select id="resSelect">
              <option value="640x360">640√ó360 (fast)</option>
              <option value="1280x720" selected>1280√ó720</option>
              <option value="1920x1080">1920√ó1080</option>
            </select>
          </label>
          <label>
            FPS
            <select id="fpsSelect">
              <option value="15">15</option>
              <option value="24">24</option>
              <option value="30" selected>30</option>
              <option value="60">60</option>
            </select>
          </label>
        </div>
        <div class="row">
          <label>
            Delay (seconds)
            <input id="delayRange" type="range" min="0" max="120" value="6" step="1" />
            <div class="statline"><span>Current delay: <strong id="delayVal">6s</strong> ¬∑ Max 120s</span></div>
          </label>
          <label>
            Delay Engine
            <select id="engineSelect">
              <option value="auto" selected>Auto (recommended)</option>
              <option value="mse">Compressed (long delay)</option>
              <option value="canvas">Memory (short)</option>
            </select>
          </label>
        </div>
        <div class="row">
          <button id="startBtn" class="btn primary">‚ñ∂ Start Camera</button>
          <button id="stopBtn" class="btn" disabled>‚ñ† Stop</button>
        </div>
        <div class="row">
          <button id="flipBtn" class="btn">üîÑ Flip (front/rear)</button>
          <button id="mirrorBtn" class="btn">ü™û Toggle Mirror</button>
        </div>
        <hr style="border:none;border-top:1px solid #1e2633; margin:4px 0;"/>
        <h2>Save a Clip (optional)</h2>
        <label>
          Clip length (seconds)
          <input id="clipLen" type="number" min="3" max="30" value="8" />
        </label>
        <div class="row">
          <button id="recordClipBtn" class="btn success" disabled>‚è∫Ô∏è Record from Delayed View</button>
          <a id="downloadLink" class="btn" style="display:none">‚¨áÔ∏è Download</a>
        </div>
        <p class="note">The clip recorder captures the delayed playback (what athletes are watching) into a downloadable file right on the device.</p>
      </div>
    </aside>

    <main class="panel">
      <h2>Preview</h2>
      <div class="video-grid">
        <div class="video-card">
          <video id="live" autoplay playsinline muted></video>
          <header>
            <span class="tag">Live Camera</span>
            <span class="tag" id="liveInfo">‚Äî</span>
          </header>
        </div>
        <div class="video-card">
          <video id="delayedVideo" autoplay playsinline muted></video>
          <canvas id="delayedCanvas" style="display:none"></canvas>
          <header>
            <span class="tag">Delayed View</span>
            <span class="tag" id="delayInfo">warming up‚Ä¶</span>
          </header>
        </div>
      </div>
      <div class="statline" id="stats">‚Äî</div>
    </main>
  </div>

  <footer>
    <p class="note">
      <strong>Notes:</strong> This runs fully in the browser (no uploads). Works on Safari, Chrome, and Edge over HTTPS. If you change cameras or resolution, hit <em>Start Camera</em> again. For best performance, keep resolution at 720p and 24‚Äì30 FPS. 60 FPS and long delays up to 120s are supported on stronger devices.
    </p>
    <p class="note warn" id="embedWarning" style="display:none">You're viewing this inside an embedded viewer, which can block camera access. Tap <strong>"Open Standalone"</strong> above to open it in its own tab, or deploy the file to an HTTPS site and open it directly (not inside a preview frame). Wix's HTML embed often sandboxes camera; linking out is most reliable.</p>
    <p class="note warn">If you see a black screen, make sure the page is served over HTTPS and you've granted camera permissions. Some browsers require a tap before video can start.</p>
  </footer>

  <script>
  (() => {
    const liveEl = document.getElementById('live');
    const delayedVideo = document.getElementById('delayedVideo');
    const delayedCanvas = document.getElementById('delayedCanvas');
    const dctx = delayedCanvas.getContext('2d');

    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const flipBtn = document.getElementById('flipBtn');
    const mirrorBtn = document.getElementById('mirrorBtn');

    const cameraSelect = document.getElementById('cameraSelect');
    const resSelect = document.getElementById('resSelect');
    const fpsSelect = document.getElementById('fpsSelect');
    const engineSelect = document.getElementById('engineSelect');

    const delayRange = document.getElementById('delayRange');
    const delayVal = document.getElementById('delayVal');
    const clipLen = document.getElementById('clipLen');
    const recordClipBtn = document.getElementById('recordClipBtn');
    const downloadLink = document.getElementById('downloadLink');

    const statsEl = document.getElementById('stats');
    const liveInfo = document.getElementById('liveInfo');
    const delayInfo = document.getElementById('delayInfo');

    // State
    let stream = null;
    let facingMode = 'environment';
    let mirrored = false;

    let targetW = 1280, targetH = 720;
    let fps = 30;
    let delaySeconds = parseInt(delayRange.value, 10);

    // Canvas (short-delay) engine state
    const MAX_DELAY_SECONDS = 120; // hard cap
    let bufferCanvases = [];
    let bufferSize = 0;
    let writeIndex = 0;
    let framesSeen = 0;
    let captureRAF = null; let captureInterval = null; let playbackInterval = null;

    // MSE (compressed long-delay) engine state
    let mediaSource = null; let sourceBuffer = null; let recorder = null; let recMimePair = null; let recTimeslice = 1000; // 1s chunks
    const chunkQueue = []; // raw blobs from recorder (newest at end)
    let appendedCount = 0; // how many chunks have been appended to MSE
    let mseStarted = false; // whether playback has started

    // Clip recorder (captures the delayed element itself)
    let clipRecorder = null;

    // ---------- Utilities ----------
    function parseRes(val) { const [w,h] = val.split('x').map(Number); return { w, h }; }
    function setCanvasSize(w, h) { delayedCanvas.width = w; delayedCanvas.height = h; }

    function pickMimePair() {
      const pairs = [
        { rec: 'video/mp4', mse: 'video/mp4; codecs="avc1.42E01E,mp4a.40.2"' },
        { rec: 'video/webm;codecs=vp9,opus', mse: 'video/webm;codecs=vp9,opus' },
        { rec: 'video/webm;codecs=vp8,opus', mse: 'video/webm;codecs=vp8,opus' },
        { rec: 'video/webm', mse: 'video/webm' }
      ];
      for (const p of pairs) {
        const recOK = (window.MediaRecorder && MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(p.rec));
        const mseOK = (window.MediaSource && MediaSource.isTypeSupported && MediaSource.isTypeSupported(p.mse));
        if (recOK && mseOK) return p;
      }
      return null;
    }

    async function listCameras() {
      try {
        const devices = await navigator.mediaDevices.enumerateDevices();
        const vids = devices.filter(d => d.kind === 'videoinput');
        cameraSelect.innerHTML = '';
        vids.forEach((d, i) => {
          const opt = document.createElement('option');
          opt.value = d.deviceId; opt.textContent = d.label || `Camera ${i+1}`; cameraSelect.appendChild(opt);
        });
        if (!vids.length) {
          const opt = document.createElement('option'); opt.value = ''; opt.textContent = 'No cameras found'; cameraSelect.appendChild(opt);
        }
      } catch (e) { console.warn('enumerateDevices failed (permissions?)', e); }
    }

    function rebuildCanvasBuffer() {
      // Compute safe internal buffer resolution & fps to control memory for long delays
      const targetFrames = Math.max(1, Math.round(Math.min(fps, 30) * Math.min(delaySeconds, MAX_DELAY_SECONDS))); // buffer fps capped 30
      // Memory budget ~ 80 MB (heuristic). Each frame ~ w*h*4 bytes. Compute scale to fit.
      const budgetBytes = 80 * 1024 * 1024; // 80MB
      let w = targetW, h = targetH;
      let bytesPerFrame = w * h * 4;
      let needed = bytesPerFrame * targetFrames;
      let scale = 1;
      while (needed > budgetBytes && scale > 0.2) { // progressively downscale
        scale *= 0.8; w = Math.max(160, Math.round(targetW * scale)); h = Math.max(90, Math.round(targetH * scale));
        bytesPerFrame = w * h * 4; needed = bytesPerFrame * targetFrames;
      }
      bufferSize = targetFrames;
      bufferCanvases = new Array(bufferSize).fill(null).map(() => { const c = document.createElement('canvas'); c.width = w; c.height = h; return c; });
      writeIndex = 0; framesSeen = 0;
      setCanvasSize(w, h);
    }

    // ---------- Start/Stop camera ----------
    async function startCamera() {
      stopEverything();
      ({w: targetW, h: targetH} = parseRes(resSelect.value));
      fps = parseInt(fpsSelect.value, 10);
      delaySeconds = parseInt(delayRange.value, 10);

      // Constraints
      const video = { width: { ideal: targetW }, height: { ideal: targetH }, frameRate: { ideal: fps } };
      if (cameraSelect.value) video.deviceId = { exact: cameraSelect.value }; else video.facingMode = { ideal: facingMode };
      const constraints = { audio: false, video };

      try {
        stream = await navigator.mediaDevices.getUserMedia(constraints);
        liveEl.srcObject = stream; liveEl.muted = true; liveEl.playsInline = true; await liveEl.play().catch(()=>{});
        listCameras();
        startBtn.disabled = true; stopBtn.disabled = false; recordClipBtn.disabled = false;
        liveEl.classList.toggle('mirrored', mirrored);

        const desiredEngine = engineSelect.value;
        const engine = (desiredEngine === 'auto') ? ((delaySeconds > 25 && pickMimePair()) ? 'mse' : 'canvas') : desiredEngine;

        if (engine === 'mse') {
          startMSEEngine();
        } else {
          startCanvasEngine();
        }

        // If inside iframe, show embed warning (Wix often blocks camera in HTML embed widgets)
        if (window.top !== window.self) { const warn = document.getElementById('embedWarning'); if (warn) warn.style.display = 'block'; }
      } catch (err) {
        console.error(err);
        const map = {
          NotAllowedError: 'Permission blocked. Click the camera icon in the address bar and allow access.',
          NotFoundError: 'No camera found. Try switching devices.',
          NotReadableError: 'Camera is in use by another app. Close other apps and try again.',
          OverconstrainedError: 'The requested resolution/FPS is not supported. Try lowering it.',
          SecurityError: 'Camera access is only available on HTTPS or localhost.'
        };
        alert(map[err.name] || 'Could not start camera. Make sure you are on HTTPS and granted camera permission.');
      }
    }

    function stopEverything() {
      // Stop loops/recorders
      if (captureRAF) { liveEl.cancelVideoFrameCallback?.(captureRAF); captureRAF = null; }
      if (captureInterval) { clearInterval(captureInterval); captureInterval = null; }
      if (playbackInterval) { clearInterval(playbackInterval); playbackInterval = null; }
      if (recorder) { try { recorder.stop(); } catch {} recorder = null; }
      if (mediaSource) { try { mediaSource.endOfStream(); } catch {} mediaSource = null; }
      if (sourceBuffer) { try { sourceBuffer.abort(); } catch {} sourceBuffer = null; }
      chunkQueue.length = 0; appendedCount = 0; mseStarted = false;

      // Stop tracks
      if (stream) { stream.getTracks().forEach(t => t.stop()); stream = null; }

      startBtn.disabled = false; stopBtn.disabled = true; recordClipBtn.disabled = true; downloadLink.style.display = 'none';
      delayInfo.textContent = 'stopped'; liveInfo.textContent = '‚Äî'; statsEl.textContent = '‚Äî';

      // Reset delayed view elements
      delayedVideo.removeAttribute('src'); if (delayedVideo.srcObject) delayedVideo.srcObject = null; delayedVideo.style.display = '';
      dctx && dctx.clearRect(0,0,delayedCanvas.width, delayedCanvas.height); delayedCanvas.style.display = 'none';
    }

    // ---------- Canvas (short delay) engine ----------
    function startCanvasEngine() {
      delayedVideo.style.display = 'none'; delayedCanvas.style.display = '';
      rebuildCanvasBuffer();

      const useRVFC = !!liveEl.requestVideoFrameCallback; const intervalMs = Math.max(1000 / Math.min(fps, 30), 16);
      let lastCapture = 0;

      function writeOneFrame() {
        if (!stream) return;
        const c = bufferCanvases[writeIndex]; const cctx = c.getContext('2d');
        cctx.drawImage(liveEl, 0, 0, c.width, c.height);
        writeIndex = (writeIndex + 1) % bufferSize; framesSeen++;
      }

      function drawDelayed() {
        const delayFrames = Math.max(0, Math.min(bufferSize-1, Math.round(Math.min(delaySeconds, MAX_DELAY_SECONDS) * Math.min(fps,30))));
        const haveFrames = Math.min(framesSeen, bufferSize);
        if (haveFrames <= delayFrames) { delayInfo.textContent = `warming up‚Ä¶ ${Math.max(0, delayFrames - haveFrames)}f`; return; }
        const readIndex = (writeIndex - delayFrames - 1 + bufferSize) % bufferSize;
        const src = bufferCanvases[readIndex]; dctx.drawImage(src, 0, 0, delayedCanvas.width, delayedCanvas.height);
        delayInfo.textContent = `${delaySeconds}s behind (memory)`;
      }

      function renderStats() {
        const delayFrames = Math.round(Math.min(delaySeconds, MAX_DELAY_SECONDS) * Math.min(fps,30));
        const have = Math.min(framesSeen, bufferSize);
        liveInfo.textContent = `${targetW}√ó${targetH}@${fps}`;
        statsEl.textContent = `Engine: Canvas ¬∑ Buffer: ${have}/${bufferSize} frames ¬∑ Current delay: ${delayFrames}f (${delaySeconds}s)`;
      }

      if (useRVFC) {
        const loop = (now) => { if (!lastCapture || (now - lastCapture) >= intervalMs - 2) { writeOneFrame(); lastCapture = now; } captureRAF = liveEl.requestVideoFrameCallback(loop); };
        captureRAF = liveEl.requestVideoFrameCallback(loop);
      } else { captureInterval = setInterval(writeOneFrame, intervalMs); }
      playbackInterval = setInterval(() => { drawDelayed(); renderStats(); }, intervalMs);

      // Mirror state
      delayedCanvas.classList.toggle('mirrored', mirrored);
    }

    // ---------- MSE (compressed long delay) engine ----------
    function startMSEEngine() {
      recMimePair = pickMimePair();
      if (!recMimePair) { console.warn('No common MediaRecorder/MediaSource MIME. Falling back to canvas.'); startCanvasEngine(); return; }

      // Build delayed video MediaSource
      mediaSource = new MediaSource();
      const msURL = URL.createObjectURL(mediaSource);
      delayedVideo.src = msURL; delayedVideo.style.display = ''; delayedCanvas.style.display = 'none';
      delayedVideo.classList.toggle('mirrored', mirrored);

      mediaSource.addEventListener('sourceopen', () => {
        try { sourceBuffer = mediaSource.addSourceBuffer(recMimePair.mse); }
        catch(e){ console.error('addSourceBuffer failed', e); alert('Your browser does not support this delay mode. Try Chrome or Safari.'); stopEverything(); return; }
        sourceBuffer.mode = 'sequence';
        sourceBuffer.addEventListener('updateend', onSBUpdateEnd);
      }, { once: true });

      // Start the recorder that feeds chunkQueue
      try { recorder = new MediaRecorder(stream, { mimeType: recMimePair.rec, videoBitsPerSecond: 2500000 }); }
      catch(e){ console.warn('MediaRecorder init failed', e); alert('Recording pipeline not supported here. Falling back to short-delay mode.'); startCanvasEngine(); return; }

      recorder.ondataavailable = (e) => { if (e.data && e.data.size) { chunkQueue.push(e.data); pumpMSE(); trimQueues(); }};
      recorder.start(recTimeslice); // fire chunks every second

      // Periodically update stats and ensure appending keeps pace
      playbackInterval = setInterval(() => { pumpMSE(); renderMSEStats(); }, 500);

      async function pumpMSE() {
        if (!sourceBuffer || !mediaSource) return;
        if (sourceBuffer.updating) return;

        const delayChunks = Math.max(0, Math.round(delaySeconds * 1000 / recTimeslice));
        // Only start once we have enough backlog
        if (!mseStarted) {
          if (chunkQueue.length <= delayChunks + 1) { delayInfo.textContent = `warming up‚Ä¶ ${delayChunks - chunkQueue.length + 1}s`; return; }
          mseStarted = true; // will begin appending from (length - delayChunks)
          appendedCount = 0; // reset timeline
        }

        // Determine next chunk to append so that playback stays delaySeconds behind
        const targetAppendIndex = Math.max(0, chunkQueue.length - delayChunks - 1);
        if (appendedCount <= targetAppendIndex) {
          const nextBlob = chunkQueue[appendedCount];
          if (!nextBlob) return; // nothing ready
          const fr = new FileReader();
          fr.onload = () => {
            try { sourceBuffer.appendBuffer(new Uint8Array(fr.result)); appendedCount++; }
            catch(e){ console.warn('appendBuffer error', e); }
          };
          fr.readAsArrayBuffer(nextBlob);
        }

        // Ensure the video is playing
        if (delayedVideo.paused && mediaSource.readyState === 'open') { delayedVideo.play().catch(()=>{}); }
        delayInfo.textContent = `${delaySeconds}s behind (compressed)`;
      }

      function trimQueues() {
        // Keep at most (delay + cushion) seconds of chunks in memory
        const cushion = 10; // seconds extra
        const maxChunks = Math.round((delaySeconds + cushion) * 1000 / recTimeslice);
        if (chunkQueue.length > maxChunks) {
          const removeCount = chunkQueue.length - maxChunks;
          chunkQueue.splice(0, removeCount);
          appendedCount = Math.max(0, appendedCount - removeCount);
          // Trim SourceBuffer if we can
          try {
            const ct = delayedVideo.currentTime;
            const removeTo = Math.max(0, ct - cushion);
            if (sourceBuffer && !sourceBuffer.updating) sourceBuffer.remove(0, removeTo);
          } catch {}
        }
      }

      function renderMSEStats() {
        liveInfo.textContent = `${targetW}√ó${targetH}@${fps}`;
        statsEl.textContent = `Engine: MSE ¬∑ Chunks: ${chunkQueue.length} stored ¬∑ Appended: ${appendedCount} ¬∑ Delay target: ${delaySeconds}s`;
      }
    }

    // ---------- Clip recording from delayed view ----------
    async function recordClipFromDelayed() {
      const el = (delayedCanvas.style.display !== 'none') ? delayedCanvas : delayedVideo;
      if (!('captureStream' in el)) { alert('Recording not supported in this browser.'); return; }
      const lengthSec = Math.max(3, Math.min(30, parseInt(clipLen.value||'8', 10)));

      // Pick a recording type that the browser supports
      let mime = '';
      const candidates = ['video/mp4', 'video/webm;codecs=vp9,opus', 'video/webm;codecs=vp8,opus', 'video/webm'];
      for (const m of candidates) { if (MediaRecorder && MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(m)) { mime = m; break; } }

      const s = el.captureStream(Math.min(fps, 60));
      const chunks = []; let cr;
      try { cr = new MediaRecorder(s, mime ? { mimeType: mime } : undefined); } catch (e) { cr = new MediaRecorder(s); }
      cr.ondataavailable = e => { if (e.data && e.data.size) chunks.push(e.data); };
      cr.onstop = () => {
        const blob = new Blob(chunks, { type: cr.mimeType || mime || 'video/webm' });
        const url = URL.createObjectURL(blob);
        downloadLink.href = url; const ts = new Date().toISOString().replace(/[:.]/g, '-'); const ext = (blob.type.includes('mp4')) ? 'mp4' : 'webm';
        downloadLink.download = `replay-${ts}.${ext}`; downloadLink.textContent = '‚¨áÔ∏è Download clip'; downloadLink.style.display = 'inline-flex';
      };
      cr.start(); recordClipBtn.disabled = true; recordClipBtn.textContent = '‚è∫Ô∏è Recording‚Ä¶';
      await new Promise(res => setTimeout(res, lengthSec * 1000)); cr.stop();
      recordClipBtn.disabled = false; recordClipBtn.textContent = '‚è∫Ô∏è Record from Delayed View';
    }

    // ---------- UI bindings ----------
    startBtn.addEventListener('click', startCamera);
    stopBtn.addEventListener('click', stopEverything);
    flipBtn.addEventListener('click', () => { facingMode = (facingMode === 'environment') ? 'user' : 'environment'; startCamera(); });
    mirrorBtn.addEventListener('click', () => { mirrored = !mirrored; liveEl.classList.toggle('mirrored', mirrored); delayedVideo.classList.toggle('mirrored', mirrored); delayedCanvas.classList.toggle('mirrored', mirrored); });
    recordClipBtn.addEventListener('click', recordClipFromDelayed);

    delayRange.addEventListener('input', () => { delaySeconds = parseInt(delayRange.value, 10); delayVal.textContent = `${delaySeconds}s`; });
    resSelect.addEventListener('change', () => { if (stream) startCamera(); });
    fpsSelect.addEventListener('change', () => { if (stream) startCamera(); });
    cameraSelect.addEventListener('change', () => { if (stream) startCamera(); });
    engineSelect.addEventListener('change', () => { if (stream) startCamera(); });

    // Device list (labels populate after first permission grant)
    listCameras();

    // Pop-out for embedded environments (e.g., Wix HTML embed)
    const popOutBtn = document.getElementById('popOutBtn');
    if (popOutBtn) popOutBtn.addEventListener('click', () => window.open(window.location.href, '_blank'));

    // Expose for quick debugging
    window.__replay = { startCamera, stopEverything };
  })();
  </script>
</body>
</html>
